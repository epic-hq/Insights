/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { Audio, BamlCtxManager, BamlRuntime, ClientRegistry, Collector, FunctionResult, Image, Pdf, Video } from "@boundaryml/baml"
import { BamlStream, type HTTPRequest, toBamlError } from "@boundaryml/baml"
import { AsyncHttpRequest, AsyncHttpStreamRequest } from "./async_request"
import {
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
} from "./globals"
import { LlmResponseParser, LlmStreamParser } from "./parser"
import type { partial_types } from "./partial_types"
import type TypeBuilder from "./type_builder"
import type * as types from "./types"
import type {
	ActionButton,
	AutoInsightsResponse,
	BBValues,
	Check,
	Checked,
	Emotions,
	EvidenceSet,
	ExecutiveInsight,
	ExtractedInsight,
	InterviewDoc,
	InterviewExtraction,
	Interviewee,
	InterviewMetadata,
	RecursivePartialNull as MovedRecursivePartialNull,
	NoteSnippet,
	OpportunityRecommendation,
	Persona,
	Persona1,
	PersonaAnalysis,
	PersonaSet,
	Set,
	SetRecord,
	Spectrum,
} from "./types"

/**
 * @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
 */
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>

type BamlCallOptions = {
	tb?: TypeBuilder
	clientRegistry?: ClientRegistry
	collector?: Collector | Collector[]
	env?: Record<string, string | undefined>
}

export class BamlAsyncClient {
	private runtime: BamlRuntime
	private ctxManager: BamlCtxManager
	private streamClient: BamlStreamClient
	private httpRequest: AsyncHttpRequest
	private httpStreamRequest: AsyncHttpStreamRequest
	private llmResponseParser: LlmResponseParser
	private llmStreamParser: LlmStreamParser
	private bamlOptions: BamlCallOptions

	constructor(runtime: BamlRuntime, ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
		this.runtime = runtime
		this.ctxManager = ctxManager
		this.streamClient = new BamlStreamClient(runtime, ctxManager, bamlOptions)
		this.httpRequest = new AsyncHttpRequest(runtime, ctxManager)
		this.httpStreamRequest = new AsyncHttpStreamRequest(runtime, ctxManager)
		this.llmResponseParser = new LlmResponseParser(runtime, ctxManager)
		this.llmStreamParser = new LlmStreamParser(runtime, ctxManager)
		this.bamlOptions = bamlOptions || {}
	}

	withOptions(bamlOptions: BamlCallOptions) {
		return new BamlAsyncClient(this.runtime, this.ctxManager, bamlOptions)
	}

	get stream() {
		return this.streamClient
	}

	get request() {
		return this.httpRequest
	}

	get streamRequest() {
		return this.httpStreamRequest
	}

	get parse() {
		return this.llmResponseParser
	}

	get parseStream() {
		return this.llmStreamParser
	}

	async CreateSet(instructions: string, __baml_options__?: BamlCallOptions): Promise<types.Set> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"CreateSet",
				{
					instructions: instructions,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.Set
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async DraftContrastPersona(
		provisional: types.Persona,
		spectrum: types.Spectrum,
		__baml_options__?: BamlCallOptions
	): Promise<types.Persona> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"DraftContrastPersona",
				{
					provisional: provisional,
					spectrum: spectrum,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.Persona
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async DraftProvisionalPersona(
		evidence: types.EvidenceSet,
		spectrum: types.Spectrum,
		__baml_options__?: BamlCallOptions
	): Promise<types.Persona> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"DraftProvisionalPersona",
				{
					evidence: evidence,
					spectrum: spectrum,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.Persona
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async ExtractEvidence(doc: types.InterviewDoc, __baml_options__?: BamlCallOptions): Promise<types.EvidenceSet> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"ExtractEvidence",
				{
					doc: doc,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.EvidenceSet
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async ExtractInsights(
		transcript: string,
		userCustomInstructions: string,
		__baml_options__?: BamlCallOptions
	): Promise<types.InterviewExtraction> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"ExtractInsights",
				{
					transcript: transcript,
					userCustomInstructions: userCustomInstructions,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.InterviewExtraction
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async ExtractPersona(
		people: string,
		insights: string,
		interviews: string,
		__baml_options__?: BamlCallOptions
	): Promise<types.Persona> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"ExtractPersona",
				{
					people: people,
					insights: insights,
					interviews: interviews,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.Persona
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async FindSpectrum(evidence: types.EvidenceSet, __baml_options__?: BamlCallOptions): Promise<types.Spectrum> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"FindSpectrum",
				{
					evidence: evidence,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.Spectrum
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async GenerateAutoInsights(
		research_data: string,
		competitive_context: string,
		business_goals: string,
		__baml_options__?: BamlCallOptions
	): Promise<types.AutoInsightsResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"GenerateAutoInsights",
				{
					research_data: research_data,
					competitive_context: competitive_context,
					business_goals: business_goals,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.AutoInsightsResponse
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async GeneratePersonas(
		interviews: string,
		people: string,
		insights: string,
		__baml_options__?: BamlCallOptions
	): Promise<types.Persona[]> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"GeneratePersonas",
				{
					interviews: interviews,
					people: people,
					insights: insights,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.Persona[]
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async NormalizeNotes(raw_notes: string, __baml_options__?: BamlCallOptions): Promise<types.InterviewDoc> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"NormalizeNotes",
				{
					raw_notes: raw_notes,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.InterviewDoc
		} catch (error) {
			throw toBamlError(error)
		}
	}

	async RefinePersonas(
		existing_persona_set: types.PersonaSet,
		new_interview_notes: string,
		__baml_options__?: BamlCallOptions
	): Promise<types.PersonaSet> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = await this.runtime.callFunction(
				"RefinePersonas",
				{
					existing_persona_set: existing_persona_set,
					new_interview_notes: new_interview_notes,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return raw.parsed(false) as types.PersonaSet
		} catch (error) {
			throw toBamlError(error)
		}
	}
}

class BamlStreamClient {
	private runtime: BamlRuntime
	private ctxManager: BamlCtxManager
	private bamlOptions: BamlCallOptions

	constructor(runtime: BamlRuntime, ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
		this.runtime = runtime
		this.ctxManager = ctxManager
		this.bamlOptions = bamlOptions || {}
	}

	CreateSet(
		instructions: string,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.Set, types.Set> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"CreateSet",
				{
					instructions: instructions,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.Set, types.Set>(
				raw,
				(a): partial_types.Set => a,
				(a): types.Set => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	DraftContrastPersona(
		provisional: types.Persona,
		spectrum: types.Spectrum,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.Persona, types.Persona> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"DraftContrastPersona",
				{
					provisional: provisional,
					spectrum: spectrum,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.Persona, types.Persona>(
				raw,
				(a): partial_types.Persona => a,
				(a): types.Persona => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	DraftProvisionalPersona(
		evidence: types.EvidenceSet,
		spectrum: types.Spectrum,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.Persona, types.Persona> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"DraftProvisionalPersona",
				{
					evidence: evidence,
					spectrum: spectrum,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.Persona, types.Persona>(
				raw,
				(a): partial_types.Persona => a,
				(a): types.Persona => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	ExtractEvidence(
		doc: types.InterviewDoc,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.EvidenceSet, types.EvidenceSet> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"ExtractEvidence",
				{
					doc: doc,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.EvidenceSet, types.EvidenceSet>(
				raw,
				(a): partial_types.EvidenceSet => a,
				(a): types.EvidenceSet => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	ExtractInsights(
		transcript: string,
		userCustomInstructions: string,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.InterviewExtraction, types.InterviewExtraction> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"ExtractInsights",
				{
					transcript: transcript,
					userCustomInstructions: userCustomInstructions,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.InterviewExtraction, types.InterviewExtraction>(
				raw,
				(a): partial_types.InterviewExtraction => a,
				(a): types.InterviewExtraction => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	ExtractPersona(
		people: string,
		insights: string,
		interviews: string,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.Persona, types.Persona> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"ExtractPersona",
				{
					people: people,
					insights: insights,
					interviews: interviews,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.Persona, types.Persona>(
				raw,
				(a): partial_types.Persona => a,
				(a): types.Persona => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	FindSpectrum(
		evidence: types.EvidenceSet,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.Spectrum, types.Spectrum> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"FindSpectrum",
				{
					evidence: evidence,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.Spectrum, types.Spectrum>(
				raw,
				(a): partial_types.Spectrum => a,
				(a): types.Spectrum => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	GenerateAutoInsights(
		research_data: string,
		competitive_context: string,
		business_goals: string,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.AutoInsightsResponse, types.AutoInsightsResponse> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"GenerateAutoInsights",
				{
					research_data: research_data,
					competitive_context: competitive_context,
					business_goals: business_goals,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.AutoInsightsResponse, types.AutoInsightsResponse>(
				raw,
				(a): partial_types.AutoInsightsResponse => a,
				(a): types.AutoInsightsResponse => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	GeneratePersonas(
		interviews: string,
		people: string,
		insights: string,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.Persona[], types.Persona[]> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"GeneratePersonas",
				{
					interviews: interviews,
					people: people,
					insights: insights,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.Persona[], types.Persona[]>(
				raw,
				(a): partial_types.Persona[] => a,
				(a): types.Persona[] => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	NormalizeNotes(
		raw_notes: string,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.InterviewDoc, types.InterviewDoc> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"NormalizeNotes",
				{
					raw_notes: raw_notes,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.InterviewDoc, types.InterviewDoc>(
				raw,
				(a): partial_types.InterviewDoc => a,
				(a): types.InterviewDoc => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}

	RefinePersonas(
		existing_persona_set: types.PersonaSet,
		new_interview_notes: string,
		__baml_options__?: {
			tb?: TypeBuilder
			clientRegistry?: ClientRegistry
			collector?: Collector | Collector[]
			env?: Record<string, string | undefined>
		}
	): BamlStream<partial_types.PersonaSet, types.PersonaSet> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: []
			const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env }
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
			)
			const raw = this.runtime.streamFunction(
				"RefinePersonas",
				{
					existing_persona_set: existing_persona_set,
					new_interview_notes: new_interview_notes,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				env
			)
			return new BamlStream<partial_types.PersonaSet, types.PersonaSet>(
				raw,
				(a): partial_types.PersonaSet => a,
				(a): types.PersonaSet => a,
				this.ctxManager.cloneContext()
			)
		} catch (error) {
			throw toBamlError(error)
		}
	}
}

export const b = new BamlAsyncClient(
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX
)
