/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { BamlRuntime, FunctionResult, BamlCtxManager, ClientRegistry, Image, Audio, Pdf, Video, FunctionLog, HTTPRequest } from "@boundaryml/baml"
import { toBamlError, BamlStream, BamlAbortError, Collector } from "@boundaryml/baml"
import type { Checked, Check, RecursivePartialNull as MovedRecursivePartialNull } from "./types"
import type { partial_types } from "./partial_types"
import type * as types from "./types"
import type {ActionButton, Anchor, AutoGroupThemesResponse, AutoInsightsResponse, BBValues, BatchEvaluationResult, Category, Chapter, ContextualSuggestions, DecisionQuestionOut, Emotions, EvidenceLinkProposal, EvidenceSet, EvidenceUnit, ExecutiveInsight, ExecutiveSummary, ExtractedInsight, FollowUpQuestion, FollowUpQuestionScores, FollowUpSet, GapAnalysis, GenerateInputs, HistoryItem, InsightMatch, InterviewDoc, InterviewExtraction, InterviewMetadata, InterviewPromptOut, Interviewee, KindTags, NoteSnippet, OpportunityRecommendation, Persona, Persona1, PersonaAnalysis, PersonaAssignmentDecision, PersonaSet, ProjectAnalysis, ProjectNameDescription, ProjectTemplateOut, Question, QuestionEvaluation, QuestionImprovement, QuestionIssue, QuestionPolicy, QuestionSet, ResearchGoal, ResearchPlanOut, ResearchQuestion, ResearchQuestionOut, ResearchQuestionSuggestions, Scores, Set, SetRecord, Source, Spectrum, SuggestedQuestion, ThemeCandidate} from "./types"
import type TypeBuilder from "./type_builder"
import { AsyncHttpRequest, AsyncHttpStreamRequest } from "./async_request"
import { LlmResponseParser, LlmStreamParser } from "./parser"
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

/**
 * @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
 */
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>

type TickReason = "Unknown";

type BamlCallOptions = {
  tb?: TypeBuilder
  clientRegistry?: ClientRegistry
  collector?: Collector | Collector[]
  env?: Record<string, string | undefined>
  signal?: AbortSignal
  onTick?: (reason: TickReason, log: FunctionLog | null) => void
}

export class BamlAsyncClient {
  private runtime: BamlRuntime
  private ctxManager: BamlCtxManager
  private streamClient: BamlStreamClient
  private httpRequest: AsyncHttpRequest
  private httpStreamRequest: AsyncHttpStreamRequest
  private llmResponseParser: LlmResponseParser
  private llmStreamParser: LlmStreamParser
  private bamlOptions: BamlCallOptions

  constructor(runtime: BamlRuntime, ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
    this.runtime = runtime
    this.ctxManager = ctxManager
    this.streamClient = new BamlStreamClient(runtime, ctxManager, bamlOptions)
    this.httpRequest = new AsyncHttpRequest(runtime, ctxManager)
    this.httpStreamRequest = new AsyncHttpStreamRequest(runtime, ctxManager)
    this.llmResponseParser = new LlmResponseParser(runtime, ctxManager)
    this.llmStreamParser = new LlmStreamParser(runtime, ctxManager)
    this.bamlOptions = bamlOptions || {}
  }

  withOptions(bamlOptions: BamlCallOptions) {
    return new BamlAsyncClient(this.runtime, this.ctxManager, bamlOptions)
  }

  get stream() {
    return this.streamClient
  }

  get request() {
    return this.httpRequest
  }

  get streamRequest() {
    return this.httpStreamRequest
  }

  get parse() {
    return this.llmResponseParser
  }

  get parseStream() {
    return this.llmStreamParser
  }

  
  async AnalyzeProjectInsights(
      research_goal: string,insights_data: string,interview_summary: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.ProjectAnalysis> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.AnalyzeProjectInsights(
          research_goal,insights_data,interview_summary,custom_instructions,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "AnalyzeProjectInsights",
        {
          "research_goal": research_goal,"insights_data": insights_data,"interview_summary": interview_summary,"custom_instructions": custom_instructions
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.ProjectAnalysis
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async AssignPersonaToInterview(
      interview_transcript: string,interviewee_info: string,existing_personas: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.PersonaAssignmentDecision> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.AssignPersonaToInterview(
          interview_transcript,interviewee_info,existing_personas,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "AssignPersonaToInterview",
        {
          "interview_transcript": interview_transcript,"interviewee_info": interviewee_info,"existing_personas": existing_personas
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.PersonaAssignmentDecision
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async AutoGroupThemes(
      evidence_json: string,guidance: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.AutoGroupThemesResponse> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.AutoGroupThemes(
          evidence_json,guidance,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "AutoGroupThemes",
        {
          "evidence_json": evidence_json,"guidance": guidance
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.AutoGroupThemesResponse
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async CreateSet(
      instructions: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.Set> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.CreateSet(
          instructions,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "CreateSet",
        {
          "instructions": instructions
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.Set
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async DraftContrastPersona(
      provisional: types.Persona,spectrum: types.Spectrum,
      __baml_options__?: BamlCallOptions
  ): Promise<types.Persona> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.DraftContrastPersona(
          provisional,spectrum,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "DraftContrastPersona",
        {
          "provisional": provisional,"spectrum": spectrum
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.Persona
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async DraftProvisionalPersona(
      evidence: types.EvidenceSet,spectrum: types.Spectrum,
      __baml_options__?: BamlCallOptions
  ): Promise<types.Persona> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.DraftProvisionalPersona(
          evidence,spectrum,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "DraftProvisionalPersona",
        {
          "evidence": evidence,"spectrum": spectrum
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.Persona
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async EvaluateInterviewQuestion(
      question: string,research_context: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.QuestionEvaluation> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.EvaluateInterviewQuestion(
          question,research_context,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "EvaluateInterviewQuestion",
        {
          "question": question,"research_context": research_context
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.QuestionEvaluation
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async EvaluateQuestionSet(
      questions: string[],research_context: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.BatchEvaluationResult> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.EvaluateQuestionSet(
          questions,research_context,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "EvaluateQuestionSet",
        {
          "questions": questions,"research_context": research_context
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.BatchEvaluationResult
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async ExtractEvidence(
      doc: types.InterviewDoc,
      __baml_options__?: BamlCallOptions
  ): Promise<types.EvidenceSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.ExtractEvidence(
          doc,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "ExtractEvidence",
        {
          "doc": doc
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.EvidenceSet
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async ExtractEvidenceFromTranscript(
      transcript: string,chapters: types.Chapter[],language: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.EvidenceUnit[]> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.ExtractEvidenceFromTranscript(
          transcript,chapters,language,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "ExtractEvidenceFromTranscript",
        {
          "transcript": transcript,"chapters": chapters,"language": language
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.EvidenceUnit[]
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async ExtractInsights(
      transcript: string,userCustomInstructions: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.InterviewExtraction> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.ExtractInsights(
          transcript,userCustomInstructions,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "ExtractInsights",
        {
          "transcript": transcript,"userCustomInstructions": userCustomInstructions
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.InterviewExtraction
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async ExtractPersona(
      people: string,insights: string,interviews: string,evidence: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.Persona> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.ExtractPersona(
          people,insights,interviews,evidence,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "ExtractPersona",
        {
          "people": people,"insights": insights,"interviews": interviews,"evidence": evidence
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.Persona
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async FillProjectTemplate(
      template_key: string,signup_data: string,project_name: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.ProjectTemplateOut> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.FillProjectTemplate(
          template_key,signup_data,project_name,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "FillProjectTemplate",
        {
          "template_key": template_key,"signup_data": signup_data,"project_name": project_name
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.ProjectTemplateOut
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async FindSpectrum(
      evidence: types.EvidenceSet,
      __baml_options__?: BamlCallOptions
  ): Promise<types.Spectrum> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.FindSpectrum(
          evidence,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "FindSpectrum",
        {
          "evidence": evidence
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.Spectrum
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GenerateAutoInsights(
      research_data: string,competitive_context: string,business_goals: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.AutoInsightsResponse> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GenerateAutoInsights(
          research_data,competitive_context,business_goals,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GenerateAutoInsights",
        {
          "research_data": research_data,"competitive_context": competitive_context,"business_goals": business_goals
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.AutoInsightsResponse
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GenerateContextualSuggestions(
      research_goal: string,current_input: string,suggestion_type: string,existing_items: string[],rejected_items: string[],project_context: string,custom_instructions: string,response_count: number,question_category?: string | null,
      __baml_options__?: BamlCallOptions
  ): Promise<string[]> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GenerateContextualSuggestions(
          research_goal,current_input,suggestion_type,existing_items,rejected_items,project_context,custom_instructions,response_count,question_category,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GenerateContextualSuggestions",
        {
          "research_goal": research_goal,"current_input": current_input,"suggestion_type": suggestion_type,"existing_items": existing_items,"rejected_items": rejected_items,"project_context": project_context,"custom_instructions": custom_instructions,"response_count": response_count,"question_category": question_category?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as string[]
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GenerateExecutiveSummary(
      research_goal: string,insights_content: string,interview_content: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.ExecutiveSummary> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GenerateExecutiveSummary(
          research_goal,insights_content,interview_content,custom_instructions,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GenerateExecutiveSummary",
        {
          "research_goal": research_goal,"insights_content": insights_content,"interview_content": interview_content,"custom_instructions": custom_instructions
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.ExecutiveSummary
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GenerateFollowUpQuestions(
      original_question: string,research_context: string,target_roles: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.FollowUpSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GenerateFollowUpQuestions(
          original_question,research_context,target_roles,custom_instructions,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GenerateFollowUpQuestions",
        {
          "original_question": original_question,"research_context": research_context,"target_roles": target_roles,"custom_instructions": custom_instructions
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.FollowUpSet
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GenerateNestedResearchQuestions(
      goal: string,decision_questions: string[],target_orgs: string,target_roles: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.ResearchPlanOut> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GenerateNestedResearchQuestions(
          goal,decision_questions,target_orgs,target_roles,custom_instructions,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GenerateNestedResearchQuestions",
        {
          "goal": goal,"decision_questions": decision_questions,"target_orgs": target_orgs,"target_roles": target_roles,"custom_instructions": custom_instructions
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.ResearchPlanOut
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GeneratePersonas(
      interviews?: string | null,people?: string | null,insights?: string | null,evidence?: string | null,
      __baml_options__?: BamlCallOptions
  ): Promise<types.Persona[]> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GeneratePersonas(
          interviews,people,insights,evidence,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GeneratePersonas",
        {
          "interviews": interviews?? null,"people": people?? null,"insights": insights?? null,"evidence": evidence?? null
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.Persona[]
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GenerateProjectNameDescription(
      signup_data: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.ProjectNameDescription> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GenerateProjectNameDescription(
          signup_data,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GenerateProjectNameDescription",
        {
          "signup_data": signup_data
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.ProjectNameDescription
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async GenerateQuestionSet(
      inputs: types.GenerateInputs,
      __baml_options__?: BamlCallOptions
  ): Promise<types.QuestionSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.GenerateQuestionSet(
          inputs,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "GenerateQuestionSet",
        {
          "inputs": inputs
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.QuestionSet
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async NormalizeNotes(
      raw_notes: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.InterviewDoc> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.NormalizeNotes(
          raw_notes,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "NormalizeNotes",
        {
          "raw_notes": raw_notes
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.InterviewDoc
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  async RefinePersonas(
      existing_persona_set: types.PersonaSet,new_interview_notes: string,
      __baml_options__?: BamlCallOptions
  ): Promise<types.PersonaSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      // Check if onTick is provided - route through streaming if so
      if (options.onTick) {
        const stream = this.stream.RefinePersonas(
          existing_persona_set,new_interview_notes,
          __baml_options__
        );
        
        return await stream.getFinalResponse();
      }
      
      const collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = await this.runtime.callFunction(
        "RefinePersonas",
        {
          "existing_persona_set": existing_persona_set,"new_interview_notes": new_interview_notes
        },
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
      )
      return raw.parsed(false) as types.PersonaSet
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
}

class BamlStreamClient {
  private runtime: BamlRuntime
  private ctxManager: BamlCtxManager
  private bamlOptions: BamlCallOptions

  constructor(runtime: BamlRuntime, ctxManager: BamlCtxManager, bamlOptions?: BamlCallOptions) {
    this.runtime = runtime
    this.ctxManager = ctxManager
    this.bamlOptions = bamlOptions || {}
  }

  
  AnalyzeProjectInsights(
      research_goal: string,insights_data: string,interview_summary: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.ProjectAnalysis, types.ProjectAnalysis> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for AnalyzeProjectInsights", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "AnalyzeProjectInsights",
        {
          "research_goal": research_goal,"insights_data": insights_data,"interview_summary": interview_summary,"custom_instructions": custom_instructions
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.ProjectAnalysis, types.ProjectAnalysis>(
        raw,
        (a): partial_types.ProjectAnalysis => a,
        (a): types.ProjectAnalysis => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  AssignPersonaToInterview(
      interview_transcript: string,interviewee_info: string,existing_personas: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.PersonaAssignmentDecision, types.PersonaAssignmentDecision> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for AssignPersonaToInterview", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "AssignPersonaToInterview",
        {
          "interview_transcript": interview_transcript,"interviewee_info": interviewee_info,"existing_personas": existing_personas
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.PersonaAssignmentDecision, types.PersonaAssignmentDecision>(
        raw,
        (a): partial_types.PersonaAssignmentDecision => a,
        (a): types.PersonaAssignmentDecision => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  AutoGroupThemes(
      evidence_json: string,guidance: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.AutoGroupThemesResponse, types.AutoGroupThemesResponse> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for AutoGroupThemes", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "AutoGroupThemes",
        {
          "evidence_json": evidence_json,"guidance": guidance
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.AutoGroupThemesResponse, types.AutoGroupThemesResponse>(
        raw,
        (a): partial_types.AutoGroupThemesResponse => a,
        (a): types.AutoGroupThemesResponse => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  CreateSet(
      instructions: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.Set, types.Set> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for CreateSet", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "CreateSet",
        {
          "instructions": instructions
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.Set, types.Set>(
        raw,
        (a): partial_types.Set => a,
        (a): types.Set => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  DraftContrastPersona(
      provisional: types.Persona,spectrum: types.Spectrum,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.Persona, types.Persona> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for DraftContrastPersona", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "DraftContrastPersona",
        {
          "provisional": provisional,"spectrum": spectrum
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.Persona, types.Persona>(
        raw,
        (a): partial_types.Persona => a,
        (a): types.Persona => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  DraftProvisionalPersona(
      evidence: types.EvidenceSet,spectrum: types.Spectrum,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.Persona, types.Persona> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for DraftProvisionalPersona", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "DraftProvisionalPersona",
        {
          "evidence": evidence,"spectrum": spectrum
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.Persona, types.Persona>(
        raw,
        (a): partial_types.Persona => a,
        (a): types.Persona => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  EvaluateInterviewQuestion(
      question: string,research_context: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.QuestionEvaluation, types.QuestionEvaluation> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for EvaluateInterviewQuestion", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "EvaluateInterviewQuestion",
        {
          "question": question,"research_context": research_context
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.QuestionEvaluation, types.QuestionEvaluation>(
        raw,
        (a): partial_types.QuestionEvaluation => a,
        (a): types.QuestionEvaluation => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  EvaluateQuestionSet(
      questions: string[],research_context: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.BatchEvaluationResult, types.BatchEvaluationResult> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for EvaluateQuestionSet", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "EvaluateQuestionSet",
        {
          "questions": questions,"research_context": research_context
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.BatchEvaluationResult, types.BatchEvaluationResult>(
        raw,
        (a): partial_types.BatchEvaluationResult => a,
        (a): types.BatchEvaluationResult => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  ExtractEvidence(
      doc: types.InterviewDoc,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.EvidenceSet, types.EvidenceSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for ExtractEvidence", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "ExtractEvidence",
        {
          "doc": doc
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.EvidenceSet, types.EvidenceSet>(
        raw,
        (a): partial_types.EvidenceSet => a,
        (a): types.EvidenceSet => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  ExtractEvidenceFromTranscript(
      transcript: string,chapters: types.Chapter[],language: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.EvidenceUnit[], types.EvidenceUnit[]> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for ExtractEvidenceFromTranscript", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "ExtractEvidenceFromTranscript",
        {
          "transcript": transcript,"chapters": chapters,"language": language
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.EvidenceUnit[], types.EvidenceUnit[]>(
        raw,
        (a): partial_types.EvidenceUnit[] => a,
        (a): types.EvidenceUnit[] => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  ExtractInsights(
      transcript: string,userCustomInstructions: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.InterviewExtraction, types.InterviewExtraction> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for ExtractInsights", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "ExtractInsights",
        {
          "transcript": transcript,"userCustomInstructions": userCustomInstructions
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.InterviewExtraction, types.InterviewExtraction>(
        raw,
        (a): partial_types.InterviewExtraction => a,
        (a): types.InterviewExtraction => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  ExtractPersona(
      people: string,insights: string,interviews: string,evidence: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.Persona, types.Persona> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for ExtractPersona", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "ExtractPersona",
        {
          "people": people,"insights": insights,"interviews": interviews,"evidence": evidence
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.Persona, types.Persona>(
        raw,
        (a): partial_types.Persona => a,
        (a): types.Persona => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  FillProjectTemplate(
      template_key: string,signup_data: string,project_name: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.ProjectTemplateOut, types.ProjectTemplateOut> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for FillProjectTemplate", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "FillProjectTemplate",
        {
          "template_key": template_key,"signup_data": signup_data,"project_name": project_name
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.ProjectTemplateOut, types.ProjectTemplateOut>(
        raw,
        (a): partial_types.ProjectTemplateOut => a,
        (a): types.ProjectTemplateOut => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  FindSpectrum(
      evidence: types.EvidenceSet,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.Spectrum, types.Spectrum> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for FindSpectrum", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "FindSpectrum",
        {
          "evidence": evidence
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.Spectrum, types.Spectrum>(
        raw,
        (a): partial_types.Spectrum => a,
        (a): types.Spectrum => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GenerateAutoInsights(
      research_data: string,competitive_context: string,business_goals: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.AutoInsightsResponse, types.AutoInsightsResponse> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GenerateAutoInsights", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GenerateAutoInsights",
        {
          "research_data": research_data,"competitive_context": competitive_context,"business_goals": business_goals
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.AutoInsightsResponse, types.AutoInsightsResponse>(
        raw,
        (a): partial_types.AutoInsightsResponse => a,
        (a): types.AutoInsightsResponse => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GenerateContextualSuggestions(
      research_goal: string,current_input: string,suggestion_type: string,existing_items: string[],rejected_items: string[],project_context: string,custom_instructions: string,response_count: number,question_category?: string | null,
      __baml_options__?: BamlCallOptions
  ): BamlStream<string[], string[]> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GenerateContextualSuggestions", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GenerateContextualSuggestions",
        {
          "research_goal": research_goal,"current_input": current_input,"suggestion_type": suggestion_type,"existing_items": existing_items,"rejected_items": rejected_items,"project_context": project_context,"custom_instructions": custom_instructions,"response_count": response_count,"question_category": question_category ?? null
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<string[], string[]>(
        raw,
        (a): string[] => a,
        (a): string[] => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GenerateExecutiveSummary(
      research_goal: string,insights_content: string,interview_content: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.ExecutiveSummary, types.ExecutiveSummary> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GenerateExecutiveSummary", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GenerateExecutiveSummary",
        {
          "research_goal": research_goal,"insights_content": insights_content,"interview_content": interview_content,"custom_instructions": custom_instructions
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.ExecutiveSummary, types.ExecutiveSummary>(
        raw,
        (a): partial_types.ExecutiveSummary => a,
        (a): types.ExecutiveSummary => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GenerateFollowUpQuestions(
      original_question: string,research_context: string,target_roles: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.FollowUpSet, types.FollowUpSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GenerateFollowUpQuestions", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GenerateFollowUpQuestions",
        {
          "original_question": original_question,"research_context": research_context,"target_roles": target_roles,"custom_instructions": custom_instructions
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.FollowUpSet, types.FollowUpSet>(
        raw,
        (a): partial_types.FollowUpSet => a,
        (a): types.FollowUpSet => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GenerateNestedResearchQuestions(
      goal: string,decision_questions: string[],target_orgs: string,target_roles: string,custom_instructions: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.ResearchPlanOut, types.ResearchPlanOut> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GenerateNestedResearchQuestions", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GenerateNestedResearchQuestions",
        {
          "goal": goal,"decision_questions": decision_questions,"target_orgs": target_orgs,"target_roles": target_roles,"custom_instructions": custom_instructions
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.ResearchPlanOut, types.ResearchPlanOut>(
        raw,
        (a): partial_types.ResearchPlanOut => a,
        (a): types.ResearchPlanOut => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GeneratePersonas(
      interviews?: string | null,people?: string | null,insights?: string | null,evidence?: string | null,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.Persona[], types.Persona[]> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GeneratePersonas", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GeneratePersonas",
        {
          "interviews": interviews ?? null,"people": people ?? null,"insights": insights ?? null,"evidence": evidence ?? null
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.Persona[], types.Persona[]>(
        raw,
        (a): partial_types.Persona[] => a,
        (a): types.Persona[] => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GenerateProjectNameDescription(
      signup_data: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.ProjectNameDescription, types.ProjectNameDescription> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GenerateProjectNameDescription", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GenerateProjectNameDescription",
        {
          "signup_data": signup_data
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.ProjectNameDescription, types.ProjectNameDescription>(
        raw,
        (a): partial_types.ProjectNameDescription => a,
        (a): types.ProjectNameDescription => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  GenerateQuestionSet(
      inputs: types.GenerateInputs,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.QuestionSet, types.QuestionSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for GenerateQuestionSet", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "GenerateQuestionSet",
        {
          "inputs": inputs
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.QuestionSet, types.QuestionSet>(
        raw,
        (a): partial_types.QuestionSet => a,
        (a): types.QuestionSet => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  NormalizeNotes(
      raw_notes: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.InterviewDoc, types.InterviewDoc> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for NormalizeNotes", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "NormalizeNotes",
        {
          "raw_notes": raw_notes
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.InterviewDoc, types.InterviewDoc>(
        raw,
        (a): partial_types.InterviewDoc => a,
        (a): types.InterviewDoc => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
  RefinePersonas(
      existing_persona_set: types.PersonaSet,new_interview_notes: string,
      __baml_options__?: BamlCallOptions
  ): BamlStream<partial_types.PersonaSet, types.PersonaSet> {
    try {
      const options = { ...this.bamlOptions, ...(__baml_options__ || {}) }
      const signal = options.signal;
      
      if (signal?.aborted) {
        throw new BamlAbortError('Operation was aborted', signal.reason);
      }
      
      let collector = options.collector ? (Array.isArray(options.collector) ? options.collector : [options.collector]) : [];
      
      let onTickWrapper: (() => void) | undefined;
      
      // Create collector and wrap onTick if provided
      if (options.onTick) {
        const tickCollector = new Collector("on-tick-collector");
        collector = [...collector, tickCollector];
        
        onTickWrapper = () => {
          const log = tickCollector.last;
          if (log) {
            try {
              options.onTick!("Unknown", log);
            } catch (error) {
              console.error("Error in onTick callback for RefinePersonas", error);
            }
          }
        };
      }

      const rawEnv = __baml_options__?.env ? { ...process.env, ...__baml_options__.env } : { ...process.env };
      const env: Record<string, string> = Object.fromEntries(
        Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [string, string][]
      );
      const raw = this.runtime.streamFunction(
        "RefinePersonas",
        {
          "existing_persona_set": existing_persona_set,"new_interview_notes": new_interview_notes
        },
        undefined,
        this.ctxManager.cloneContext(),
        options.tb?.__tb(),
        options.clientRegistry,
        collector,
        env,
        signal,
        onTickWrapper,
      )
      return new BamlStream<partial_types.PersonaSet, types.PersonaSet>(
        raw,
        (a): partial_types.PersonaSet => a,
        (a): types.PersonaSet => a,
        this.ctxManager.cloneContext(),
        options.signal,
      )
    } catch (error) {
      throw toBamlError(error);
    }
  }
  
}

export const b = new BamlAsyncClient(DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME, DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX)