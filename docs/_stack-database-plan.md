# Tech Stack and Conventions

## Last updated: 2025-08-05

This document describes the architecture and conventions (ways of doing things) in the app, including auth, how to structure the code, how to manage data and state in components, middleware, and API routes, media storage, and database schema and conventions. We will explain in plain language first, then provide the technical details with examples so AI or human dev can follow and help enforce consistency and good patterns.

## Users and Accounts

When a user logs into the application, they have a personal ID and that creates a `account_user` record where their personal ID is both in the `user_id` and the `account_id`. We also automatically create a Team Account, which is a new `account_id` and a row that shows the `user_id` with a new `account_id`. This team account allows them to invite others to be members of their team.

We should ALWAYS use the user's "Team" account `accounts.id` or `account_user.account_id` to access the account. The personal account should only be used for login and authentication. `account_user.user_id` should be used to identify the member of the (team) account, think of it as a member_id.

Future feature will allow them to 1. select their team account, add others as members to the team account.

When we activate a team account, we create a new `account_id` and update the `account_user` record to show the `user_id` with the new `account_id`.

Account selection UI:
If the user has only a personal account, auto-select it.
If the user has multiple accounts, show a modal or page listing all their teams (and personal account, if you want to allow "My Stuff").
Store the selected account_id in a React context, cookie, or localStorage for the session.
Route construction:
All collaborative routes should be /a/:accountId/... and use the selected team account_id.
When switching teams, update the context and redirect to the new team's dashboard.
Default behavior:
On first login, if the user only has a personal account, offer to create a team or start a project in their personal account.
When a team is created or the user is invited to a team, switch context to that team.
Where in your app:

After login in your auth callback or root loader:
Fetch all accounts for the user and set the active account context.
In your main layout or dashboard loader:
Check for an active account context; if missing, redirect to account selection.
In your project/resource creation forms:
Use the active account_id for all new resources.

## Context & Information flow

_ProtectedLayout. Loader gets user, accounts & project info and adds into react context CurrentProjectContext.
/dashboard uses it.
MainNav uses it for nav links. Non-logged in users should only see public links.

What route to use for project detail page? /projects/:projectId or /projects/:projectId/:tab was old way before we introduced the /a/:accountId/:projectId/ prefix. So now the project detail page should be /a/:accountId/:projectId/. The projectsRoutes.ts file should be updated to use this new route for the detail page. But we need to ensure that a link to another page within the project still shows without showing the projectDetail page. e.g. /a/:accountId/:projectId/interviews should show the interviews page.
And projectDetail page can use CurrentProjectContext to get the project info.

## Table of Contents

## 1. Stack Overview

| Layer | Choice | Rationale |
|-------|--------|----------|
| Types | snake_case everywhere - DB & App | Supabase uses snake_case for table names and variables, and this is easy to read and no surprises or need to convert in FE. transient variables in react can still use camelCase if desired. |
| Relational DB | **Postgres (Supabase)** | Managed Postgres with integrated auth & RLS; fits structured research data. |
| Auth | **Supabase Auth** | Email / SSO; interviewer accounts map to `auth.users`. |
| Media Storage | **Cloudflare R2** | Low-cost object storage for large audio / video files. Supabase stores only signed-URL + metadata. |
| Vector Search (future) | **pgvector** extension on Supabase | Enables semantic similarity between themes / categories. |
| App Framework | **React Router 7** | Universal React routing with feature-based organization; middleware-based auth; context-driven data access; allows o3/BAML processing in loaders/actions. |

## 2. Tenancy & ACL Model

* Multi-tenant SaaS → every row scoped by `accounts.account_id` (UUID).
* `accounts` & `user_accounts` control membership & roles.
* Row-Level Security (RLS) policies restrict CRUD to members of the same `account_id`.
* Media ACL: Not stored right now, just uploading to AAI for transcription. Future: files stored in R2 under path `account_id/<uuid>`.  Download/stream via **signed URLs** generated by a Supabase Edge Function that validates the caller’s JWT & account membership.

## 3. High-Level Entity Diagram

<!-- TODO: add diagram -->

## 4. Table & Types Specifications (supabase schema `public`)

This project strictly follows the declarative schema definition approach defined (here)[`/docs/supabase-howto.md`].

### 4.x Types

Types are generated from the DB schema using `supabase/types.ts`. Run `supabase gen types typescript --project-id rbginqvgkonnoktrttqv > supabase/types.ts` to generate the types and then add the one-line export type … = Tables<"..."> helper in the relevant feature’s types.ts.

Auto-generate types from queries in our db.ts files that components can import. We can get the nested CountriesWithCities type like this:

```ts
import { QueryResult, QueryData, QueryError } from '@supabase/supabase-js'
const countriesWithCitiesQuery = supabase.from('countries').select(`
  id,
  name,
  cities (
    id,
    name
  )
`)
type CountriesWithCities = QueryData<typeof countriesWithCitiesQuery>
const { data, error } = await countriesWithCitiesQuery
if (error) throw error
const countriesWithCities: CountriesWithCities = data
```

Reference: [docs](https://supabase.com/docs/guides/api/rest/generating-types#type-shorthands)

Prefer typed columns for data, but in future if we need to store JSONB, use `https://supabase.com/docs/guides/api/rest/generating-types#defining-custom-json-types` to define custom JSON types.

### 4.1  Core Multi-Tenant Accounts in schema `accounts`

Using basejump inspired separate accounts schema
Migration files for setting up and configuration done.
Definitive table specs to be stored in `supabase/schemas`

### Core Tables

accounts
accounts_users
projects
people
personas
interviews
insights
tags
opportunities

TODO:

* [x] separate tables into files
* [x] add indexes, triggers, RLS policies
* [x] renamed research_projects -> projects. modify in FE too
* [x] error saving new user (maybe due to missing org_id and incomplete setup of new schema. Redo and retry)
* [x] New user signup should create account and project
* [x] AddInterview button needs accountId and projectId to send to /api/upload-file in body. _NavLayout loader gets this db and passes it down in AuthContext. So AddInterviewButton should get it from there via useAuthContext?

## 4.10 Vector Similarity (pgvector)

* Enable `CREATE EXTENSION IF NOT EXISTS pgvector;` on Supabase.
* Store `embedding` vectors for `themes` & optionally `insights`.
* Example query to populate embeddings with OpenAI:

  ```sql
  update themes
  set embedding = openai_embed(name)
  where embedding is null;
  ```

## 4.11 Creation & Updates & ACLs

### 4.11.1 Creation

When a user signs up, they are created in `auth.users` by Supabase,
Triggers should then:

* create a default `organizations` record with `name: "My Team"` and `role: owner`.
* create a default `user_org_memberships` record with `role: owner`.
* create a default `user_settings` record with `theme: "dark"`, `language: "en"`, `title: ""`, `role: "interviewer"`, `onboarding_completed: false`, `app_activity: {}`, `metadata: {}`.
* create a default `research_projects` record with `code: "001"` and `title: "My First Project"` and `org_id` linked to the default `organizations` record.

### 4.11.2 Updates

* Create a trigger for insert and update to set field `updated_at` to `now()`.
* Run this trigger on all tables that have an `updated_at` field.

### 4.11.3 ACLs

* Row-Level Security (RLS) policies restrict CRUD to members of the same `org_id`.

## 4.11.3 ACLs

* Row-Level Security (RLS) policies restrict CRUD to members of the same `org_id`.
**`insights`**, **`quotes`**, **`themes`**, **`opportunities`**, **`personas`**, **`research_projects`**, **`people`**, **`interviews`**, **`media_files`**:
  * Members of the org can read, create, update, delete rows in these tables

The following tables have additional policies:

* **`organizations`**:
  * `insert` open only to API/service role; users never create orgs directly.
  * No delete by user.
  * Only owner can update.
  * (Prevent spam orgs.)

* **`user_org_memberships`**:
  * `select` owners; members see only their own row.
  * `insert/delete` owners only.
  * (Hide the full roster from non-admins.)

* **`account_settings`**:
  * Use `account_id = auth.uid()` in addition to `is_in_org(org_id)` for read/write.
  * (Each user edits only their prefs.)

* **`media_files`**:
  * Allow `insert` when `uploaded_by = auth.uid()` and `is_in_org(org_id)`.
  * (Enforce proper attribution.)

* **`tags`** (global):
  * Leave RLS **off** or make it read-only for everyone, insert/update restricted to service role.
  * (Shared glossary.)

Materialized views (`theme_counts_mv`) refresh under service role; add `for select using (is_in_org(org_id))` if it has `org_id`. (Keep isolation consistent.)

* Media ACL: files stored in R2 under path `org_id/<uuid>`.  Download/stream via **signed URLs** generated by a Supabase Edge Function that validates the caller’s JWT & org membership.

### Core Pattern Sample Code

```sql
-- helper that lists the orgs the signed‑in user belongs to
create or replace view v_current_user_orgs as
select org_id, role
from public.user_org_memberships
where user_id = auth.uid();

-- convenience Boolean (faster than EXISTS sub‑query)
create or replace function is_in_org(uuid) returns boolean
language sql stable as $$
  select exists(
    select 1 from v_current_user_orgs where org_id = $1
  );
$$;
```

**Default policy template**

```sql
alter table <TABLE> enable row level security;

-- Read
create policy "org members can read"
  on <TABLE>
  for select
  using ( is_in_org(org_id) );

-- Write (any member)
create policy "org members can insert"
  on <TABLE>
  for insert
  with check ( is_in_org(org_id) );

-- Update/Delete (only owners)
create policy "only owners can modify"
  on <TABLE>
  for update using ( exists (
        select 1 from v_current_user_orgs
        where org_id = <TABLE>.org_id and role = 'owner'
  ));
create policy "only owners can delete"
  on <TABLE>
  for delete using ( exists (
        select 1 from v_current_user_orgs
        where org_id = <TABLE>.org_id and role = 'owner'
  ));
```

## 5. Routing

We are using programmatic route files, rolled up into app/routes.ts to support feature consolidation, where a feature directory has components, pages and a route file. Each feature route file gets aggregated into a single app/routes.ts. [docs](https://reactrouter.com/start/framework/routing)

| Syntax                         | Resulting URL / behaviour                                                                       | Built‑in?                                                         |
| ------------------------------ | ----------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `_index.tsx`                   | Parent URL itself (index route)                                                                 | ✔                                                                 |
| `parent.child.tsx`             | `/parent/child` (the dot adds **/** and nests layouts)                                          | ✔ ([React Router][1])                                             |
| `$id.tsx`                      | `/123` dynamic segment → `params.id`                                                            | ✔ ([React Router][1])                                             |
| `($lang).page.tsx`             | `/page` **or** `/en/page` – segment wrapped in **()** is *optional*                             | ✔ ([React Router][1])                                             |
| `_auth.login.tsx`              | `/login` but rendered inside a hidden “auth” layout (leading `_` creates a **pathless layout**) | ✔ ([React Router][1])                                             |
| `parent_.mine.tsx`             | `/parent/mine` with **no** parent layout (trailing `_` removes layout nesting)                  | ✔ ([React Router][1])                                             |
| `$.tsx` or `files.$.tsx`       | Splat / catch‑all (`/anything`)                                                                 | ✔ ([React Router][1])                                             |
| `sitemap[.]xml.tsx`            | Escapes special chars → `/sitemap.xml`                                                          | ✔ ([React Router][1])                                             |
| `folder+` (e.g. `_dashboard+`) | Treat folder as a route segment **and** let you co‑locate extra files without becoming routes   | **➕ Requires** community add‑on `remix-flat-routes` ([GitHub][2]) |

[1]: https://reactrouter.com/how-to/file-route-conventions "File Route Conventions  | React Router"
[2]: https://github.com/remix-run/remix/discussions/8473 "Nested folders and nested / non-nested routes · remix-run remix · Discussion #8473 · GitHub"

## 6 in sep file. `feature-spec-ingest.md`

## 7. Pipeline Orchestration

### 7.1 Transcription

Implement a pipeline queue for handling different stages of the transcription process.
This will be more robust incase of error, and should prevent data loss, enabling restarts, etc.
Can also update user notifications to show progress.

* Allow user to past transcript file to the Add Interview button. The tranascript text should be added into an `interview` row in the DB.
And start the transcription pipeline from the `transcribe` pgmq queue.

TODO: Add details on how.

```mermaid
graph TD
    A(User uploads media) --> B[Store URL (Drive or R2)]
    B --> C[AssemblyAI Transcription]
    C -->|transcript ready| D[Save transcript to DB]
    D --> E[pgmq: enqueue 'transcribe']
    E --> F[o3 + BAML worker]
    F --> G[Insert insights & embeddings]
    G --> H[Notify user]
```

* **Queues / Workers** – `pgmq` for reliable jobs; future heavy processing via Edge Function.
* **Security** – presigned R2 URLs validated by org JWT.

## 8. Setup pipeline

* Add pgmq queue for transcript processing to supabase. Done. named 'transcribe' and added to schema
* Define pipeline flow to handle transcript processing: Provide File URL -> transacribe audio with assembly AI  -> save to db -> notify user

* <https://github.com/pgmq/pgmq?tab=readme-ov-file#sql-examples>

## 9. Migration & Seeding Strategy

* All DB structure is defined with declarative schemas in `supabase/schemas`.  Migrations are auto-generated via `supabase db diff` and stored in `supabase/migrations`. We then run `supabase db push` to apply the migrations to the database. or `supabase db reset` to reset the database to the state of the migration files. It will drop the database and recreate it from the migration files and run seed.sql.
* pgvector enabled in initial migration.
* Seed scripts insert default categories, sample tags, and demo personas for Storybook/testing.

* [ ] Figure out how to run embedding migrations to install extensions

---

Please **review** and confirm or suggest edits. Once approved I will:

1. Add helper Edge Function stubs for R2 upload/download.
2. Add pgmq queue for transcript processing.

* <https://github.com/pgmq/pgmq?tab=readme-ov-file#sql-examples>

3. Implement adaptive embedding search: <https://supabase.com/blog/matryoshka-embeddings>

## Notes

When we modify the schema, we should run `supabase db diff` to generate a migration. This will create a new migration file in the `supabase/migrations` directory. We should then run `supabase db push` to apply the migration to the database. or `supabase db reset` to reset the database to the state of the migration files. It will drop the database and recreate it from the migration files and run seed.sql.

## Reference docs and code samples

* Transcribe using AssemblyAI. [AssemblyAI docs](https://www.assemblyai.com/docs/getting-started/transcribe-an-audio-file)
* AssemblyAI can transcribe google drive files.
* [how to convert google files to downloadable](https://www.assemblyai.com/docs/guides/transcribing-google-drive-file)
* [supabase automatic embeddings](https://supabase.com/docs/guides/ai/automatic-embeddings)
* Using Supabase functions to generate embeddings. see [supabase-howto.md](supabase-howto.md)
